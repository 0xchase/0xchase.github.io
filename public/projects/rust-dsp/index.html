<!DOCTYPE html>
<html lang="en">
    <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
        <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="author" content="Chase Kanipe ">
<meta name="description" content="Introduction In this post I’m going to attempt to show some of the advantages the rust type system brings to writing more elegant DSP code. We&amp;rsquo;re going to start with a crash course on the relevant parts of the rust type system, and then we&amp;rsquo;ll see how this can be applied to constructing the types and traits that will be the foundation of a Rust audio processing library. We&amp;rsquo;ll then see how to apply some more abstract features of the Rust type system to make these elements more composable and modular." />
<meta name="keywords" content=", Rust, Audio Programming" />
<meta name="robots" content="noodp" />
<meta name="theme-color" content="" />
<link rel="canonical" href="http://localhost:1313/projects/rust-dsp/" />




    <title>
        
            Writing Elegant DSP Code in Rust – Chase Kanipe 
        
    </title>





<link rel="stylesheet" href="/main.53ef77a56bd39ea381ed99b0cd5f8ed88aa86aa70032d949cdca30b30c15fe6a.css" integrity="sha256-U&#43;93pWvTnqOB7ZmwzV&#43;O2IqoaqcAMtlJzcowswwV/mo=">



    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/site.webmanifest">
    <link rel="mask-icon" href="/safari-pinned-tab.svg" color="">
    <link rel="shortcut icon" href="/favicon.ico">
    <meta name="msapplication-TileColor" content="">


<meta itemprop="name" content="Writing Elegant DSP Code in Rust">
<meta itemprop="description" content="Introduction In this post I’m going to attempt to show some of the advantages the rust type system brings to writing more elegant DSP code. We&rsquo;re going to start with a crash course on the relevant parts of the rust type system, and then we&rsquo;ll see how this can be applied to constructing the types and traits that will be the foundation of a Rust audio processing library. We&rsquo;ll then see how to apply some more abstract features of the Rust type system to make these elements more composable and modular."><meta itemprop="datePublished" content="2023-11-01T00:00:02-04:00" />
<meta itemprop="dateModified" content="2023-11-01T00:00:02-04:00" />
<meta itemprop="wordCount" content="4977">
<meta itemprop="keywords" content="Rust,Audio Programming," />
<meta name="twitter:card" content="summary"/><meta name="twitter:title" content="Writing Elegant DSP Code in Rust"/>
<meta name="twitter:description" content="Introduction In this post I’m going to attempt to show some of the advantages the rust type system brings to writing more elegant DSP code. We&rsquo;re going to start with a crash course on the relevant parts of the rust type system, and then we&rsquo;ll see how this can be applied to constructing the types and traits that will be the foundation of a Rust audio processing library. We&rsquo;ll then see how to apply some more abstract features of the Rust type system to make these elements more composable and modular."/>







    <meta property="article:published_time" content="2023-11-01 00:00:02 -0400 EDT" />











    </head>

    
<div class="float-container">
    <a id="dark-mode-toggle">
        <i class="theme-toggle not-selectable"><svg class="theme-toggler" width="24" height="24" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg">
   <path d="M22 41C32.4934 41 41 32.4934 41 22C41 11.5066 32.4934 3 22
   3C11.5066 3 3 11.5066 3 22C3 32.4934 11.5066 41 22 41ZM7 22C7
   13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22Z"/>
 </svg></i>
    </a>
</div>


    
        <body>
    
    
        <div class="container">
            <header class="header">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
    <span class="header__inner">
        <a href="/" style="text-decoration: none;">
    <div class="logo">
        
            <span class="logo__mark">$</span>
            <span class="logo__text logo__pathname">
                /home/</span>
            <span class="logo__cursor" style=
                  "
                   
                   animation-duration:1s;">
            </span>
        
    </div>
</a>


        <span class="header__right">
            
                <nav class="menu">
    <ul class="menu__inner">
            <li><a href="/about/">About</a></li>
            <li><a href="/cv/">CV</a></li>
            <li><a href="/projects/">Projects</a></li>
            <li><a href="/music/">Music</a></li>
            <li><a href="/blog/">Blog</a></li>
    </ul>
</nav>

                <span class="menu-trigger">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                        <path d="M0 0h24v24H0z" fill="none"/>
                        <path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/>
                    </svg>
                </span>
            
        </span>
    </span>
</header>


            <div class="content">
                
    <main class="post">

        <div class="post-info">
            
            </p>
        </div>

        <article>
            <h2 class="post-title"><a href="http://localhost:1313/projects/rust-dsp/">Writing Elegant DSP Code in Rust</a></h2>
            <div class="post-meta"><span title='2023-11-01 00:00:02 -0400 EDT'>November 1, 2023</span>&nbsp;·&nbsp;24 min&nbsp;·&nbsp;4977 words</div>

            
            
            <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#introduction" aria-label="Introduction">Introduction</a></li>
                <li>
                    <a href="#preview" aria-label="Preview">Preview</a></li>
                <li>
                    <a href="#rust-basics" aria-label="Rust Basics">Rust Basics</a><ul>
                        
                <li>
                    <a href="#structs-and-methods" aria-label="Structs and Methods">Structs and Methods</a></li>
                <li>
                    <a href="#generics" aria-label="Generics">Generics</a></li>
                <li>
                    <a href="#traits" aria-label="Traits">Traits</a></li>
                <li>
                    <a href="#associated-types" aria-label="Associated Types">Associated Types</a></li>
                <li>
                    <a href="#trait-bounds" aria-label="Trait Bounds">Trait Bounds</a></li>
                <li>
                    <a href="#buffer-improvements" aria-label="Buffer Improvements">Buffer Improvements</a></li></ul>
                </li>
                <li>
                    <a href="#floats-samples-and-buffers" aria-label="Floats, Samples, and Buffers">Floats, Samples, and Buffers</a><ul>
                        
                <li>
                    <a href="#sample-trait" aria-label="Sample Trait">Sample Trait</a></li>
                <li>
                    <a href="#block-trait" aria-label="Block Trait">Block Trait</a></li>
                <li>
                    <a href="#more-methods" aria-label="More Methods">More Methods</a></li></ul>
                </li>
                <li>
                    <a href="#processors-and-generators" aria-label="Processors and Generators">Processors and Generators</a><ul>
                        
                <li>
                    <a href="#node-composition" aria-label="Node Composition">Node Composition</a></li>
                <li>
                    <a href="#node-initialization" aria-label="Node Initialization">Node Initialization</a></li>
                <li>
                    <a href="#testing" aria-label="Testing">Testing</a></li></ul>
                </li>
                <li>
                    <a href="#summary" aria-label="Summary">Summary</a>
                </li>
            </ul>
        </div>
    </details>
</div>


            <div class="post-content">
                <h2 id="introduction">Introduction</h2>
<p>In this post I’m going to attempt to show some of the advantages the rust type system brings to writing more elegant DSP code. We&rsquo;re going to start with a crash course on the relevant parts of the rust type system, and then we&rsquo;ll see how this can be applied to constructing the types and traits that will be the foundation of a Rust audio processing library. We&rsquo;ll then see how to apply some more abstract features of the Rust type system to make these elements more composable and modular.</p>
<p>But first, as a point of clarification, what exactly do I mean by elegant? Well, for the purposes of this talk, I&rsquo;m going to define it with the following list.</p>
<ul>
<li><strong>Expressive</strong>: Concise and readable</li>
<li><strong>Flexible</strong>: Usable in a variety of contexts</li>
<li><strong>Composable</strong>: Elements can be easily combined into graphs</li>
</ul>
<p>We want to accomplish this without there being much of a cost in terms of <strong>safety</strong> and <strong>performance</strong>.</p>
<h2 id="preview">Preview</h2>
<p>Just to preview what will be covered in this article. The expectation is that you start knowing something about programming and very little about Rust spcifically. By the middle of this talk you&rsquo;ll have enough understanding of the Rust type system to decipher cryptic looking abstract types like this one.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">#[derive(Copy, Clone)]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Chain</span><span style="color:#f92672">&lt;</span>P1, P2<span style="color:#f92672">&gt;</span>(<span style="color:#66d9ef">pub</span> P1, <span style="color:#66d9ef">pub</span> P2);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>In, Between, Out, P1, P2<span style="color:#f92672">&gt;</span> Processor <span style="color:#66d9ef">for</span> Chain<span style="color:#f92672">&lt;</span>P1, P2<span style="color:#f92672">&gt;</span> 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">where</span>
</span></span><span style="display:flex;"><span>        P1: <span style="color:#a6e22e">Processor</span><span style="color:#f92672">&lt;</span>Input <span style="color:#f92672">=</span> In, Output <span style="color:#f92672">=</span> Between<span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>        P2: <span style="color:#a6e22e">Processor</span><span style="color:#f92672">&lt;</span>Input <span style="color:#f92672">=</span> Between, Output <span style="color:#f92672">=</span> Out<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Input</span> <span style="color:#f92672">=</span> In;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Output</span> <span style="color:#f92672">=</span> Out;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">prepare</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self, sample_rate: <span style="color:#66d9ef">f64</span>, block_size: <span style="color:#66d9ef">usize</span>) {
</span></span><span style="display:flex;"><span>        self.<span style="color:#ae81ff">0.</span>prepare(sample_rate, block_size);
</span></span><span style="display:flex;"><span>        self.<span style="color:#ae81ff">1.</span>prepare(sample_rate, block_size);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">process</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self, input: <span style="color:#a6e22e">Self</span>::Input) -&gt; <span style="color:#a6e22e">Self</span>::Output {
</span></span><span style="display:flex;"><span>        self.<span style="color:#ae81ff">1.</span>process(self.<span style="color:#ae81ff">0.</span>process(input))
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Which we&rsquo;ll be using in the process of developing the backend of our DSP library. When this process is done we&rsquo;ll have created most of the fundemental data structures needed for DSP programming, and we&rsquo;ll have a simple interface to our library with elements that can be composed using a faust-like syntax. Our goal is to achieve this simple syntax without the need of a domain-specific language. Here&rsquo;s an example.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> input <span style="color:#f92672">=</span> Block::init(<span style="color:#ae81ff">0.0</span>, <span style="color:#ae81ff">512</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> output <span style="color:#f92672">=</span> Block::init(<span style="color:#ae81ff">0.0</span>, <span style="color:#ae81ff">512</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> lfo <span style="color:#f92672">=</span> lfo(<span style="color:#ae81ff">0.5</span>) <span style="color:#f92672">&gt;&gt;</span> gain(<span style="color:#f92672">-</span><span style="color:#ae81ff">10.0</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> graph <span style="color:#f92672">=</span> distortion(<span style="color:#ae81ff">10.0</span>) <span style="color:#f92672">&gt;&gt;</span> gain(lfo) <span style="color:#f92672">&gt;&gt;</span> gain(<span style="color:#f92672">-</span><span style="color:#ae81ff">10.0</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    graph.process_block(<span style="color:#f92672">&amp;</span>input, <span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> output);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>To make sure the rest of this talk is broadly accessible to non rustaceans, I&rsquo;m going to introduce new aspects of the Rust types system as they become relevant to the feature we&rsquo;re implementing. We&rsquo;re going to start with the simple, naive implementation of vaious library features like buffers and processors, and then gradually iterate on them to take advantage of more advanced features of the Rust type system.</p>
<hr>
<h2 id="rust-basics">Rust Basics</h2>
<h3 id="structs-and-methods">Structs and Methods</h3>
<p>Like many languages, Rust supports composing types into a <code>struct</code> as well as implementing methods on that struct. A <code>struct</code> may have multiple members and they will be accessible to the methods implemented on it. As an example we can make a first pass at creating one for our audio buffer.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">AudioBuffer</span> {
</span></span><span style="display:flex;"><span>    data: Vec<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">f32</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>As you can see this buffer is essentially a wrapper around a vector of 32 bit floats. We can implement various methods on this struct.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">impl</span> AudioBuffer {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">new</span>() -&gt; <span style="color:#a6e22e">Self</span> {
</span></span><span style="display:flex;"><span>        Self {
</span></span><span style="display:flex;"><span>            data: Vec::new()
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">len</span>(<span style="color:#f92672">&amp;</span>self) -&gt; <span style="color:#66d9ef">usize</span> {
</span></span><span style="display:flex;"><span>        self.data.len()
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">zero</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> s <span style="color:#66d9ef">in</span> <span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self.data {
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">*</span>s <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.0</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>As you can see, the first method we implemented doesn&rsquo;t take a <code>self</code> type as an argument, so it should be called using the <code>::</code> syntax instead of the <code>.</code> syntax. It&rsquo;s a standard convention for the <code>new</code> function to create a new instance of that type.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> buffer <span style="color:#f92672">=</span> AudioBuffer::new();
</span></span></code></pre></div><p>Our other methods both take a reference to <code>self</code>. You can see that the first one just returns the length of the buffer, and the second one zeros the contents of data. Importantly, you might have noticed that the second method specifically takes a <em>mutable</em> reference to <code>self.</code> Remember that in Rust, variables are immutable by default. So in order to modify the contents of <code>data</code>, we need to use the <code>mut</code> keyword when getting a reference to it.</p>
<h3 id="generics">Generics</h3>
<p>Like other languages, Rust also has support for generics, which can be used both in structs and functions. We&rsquo;ll generalize our <code>AudioBuffer</code> type into a <code>Buffer</code> type, and then we&rsquo;ll change our implementation to only apply to a specific generic value.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Buffer</span><span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    data: Vec<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> Buffer<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">new</span>() -&gt; <span style="color:#a6e22e">Self</span> {
</span></span><span style="display:flex;"><span>        Self {
</span></span><span style="display:flex;"><span>            data: Vec::new()
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">len</span>(<span style="color:#f92672">&amp;</span>self) -&gt; <span style="color:#a6e22e">Self</span> {
</span></span><span style="display:flex;"><span>        self.data.len()
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>As you can see above, our buffer type is now generic over any kind of contents. We can&rsquo;t implement our zero method on it generically, though, since the contents won&rsquo;t always be a <code>f32</code>, but we <em>can</em> implement it on a specific value of the generic, as seen below.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">impl</span> Buffer<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">f32</span><span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">zero</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> s <span style="color:#66d9ef">in</span> <span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self.data {
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">*</span>s <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.0</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">rms</span>(<span style="color:#f92672">&amp;</span>self) -&gt; <span style="color:#66d9ef">f32</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// TODO
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>We can also alias a <code>Buffer&lt;f32&gt;</code> to an <code>AudioBuffer</code>, so we can use our new more generic type the same as our previous one.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">AudioBuffer</span> <span style="color:#f92672">=</span> Buffer<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">f32</span><span style="color:#f92672">&gt;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> buffer <span style="color:#f92672">=</span> AudioBuffer::new();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> rms <span style="color:#f92672">=</span> buffer.rms();
</span></span><span style="display:flex;"><span>    buffer.zero();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="traits">Traits</h3>
<p>Okay. With the basics out of the way we&rsquo;re going to take a brief detour to introduce traits. We&rsquo;ll return to our buffer struct once we&rsquo;ve covered traits and trait bounds.</p>
<p>Superficially you can think of traits as like Rust&rsquo;s version of a class or interface, and they can be used to define a set of implemented or unimplemented methods associated with that trait. For our library, we&rsquo;ll use the example of an <code>AudioProcessor</code>. Here&rsquo;s a naive implementation of our trait.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">trait</span> AudioProcessor {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">process</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self, input: <span style="color:#66d9ef">f32</span>) -&gt; <span style="color:#66d9ef">f32</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>As you can see, our processor method has unimplemented prepare and process methods. We can implement this trait on any type. We&rsquo;ll use a simple distortion as an example.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Distortion</span> {
</span></span><span style="display:flex;"><span>    gain: <span style="color:#66d9ef">f32</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span> Distortion {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">new</span>() -&gt; <span style="color:#a6e22e">Self</span> {
</span></span><span style="display:flex;"><span>        Self {
</span></span><span style="display:flex;"><span>            gain: <span style="color:#ae81ff">0.0</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">set_gain</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self: <span style="color:#a6e22e">gain</span>: <span style="color:#66d9ef">f32</span>) {
</span></span><span style="display:flex;"><span>        self.gain <span style="color:#f92672">=</span> gain;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span> AudioProcessor <span style="color:#66d9ef">for</span> Distortion {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">process</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self, input: <span style="color:#66d9ef">f32</span>) -&gt; <span style="color:#66d9ef">f32</span> {
</span></span><span style="display:flex;"><span>        input <span style="color:#f92672">*</span> db_to_linear(self.gain)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">db_to_linear</span>(f: <span style="color:#66d9ef">f32</span>) -&gt; <span style="color:#66d9ef">f32</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// something here
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> distortion <span style="color:#f92672">=</span> Distortion::new();
</span></span><span style="display:flex;"><span>    distortion.set_gain(<span style="color:#ae81ff">10.0</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> output <span style="color:#f92672">=</span> distortion.process(<span style="color:#ae81ff">5.0</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>As you can see, we&rsquo;ve declared a distortion with a <code>new</code> and <code>set_gain</code> function, then we&rsquo;ve implemented our <code>AudioProcessor</code> trait on it. Note that user defined traits can be implemented on almost any type you want. For example, I&rsquo;m not sure why you&rsquo;d want to do this, but we could even implement it on a float type.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">impl</span> AudioProcessor <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">f32</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">process</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self, input: <span style="color:#66d9ef">f32</span>) -&gt; <span style="color:#66d9ef">f32</span> {
</span></span><span style="display:flex;"><span>        input <span style="color:#f92672">*</span> db_to_linear(self.gain)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> output <span style="color:#f92672">=</span> <span style="color:#ae81ff">10.0.</span>process(<span style="color:#ae81ff">5.0</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Again, you wouldn&rsquo;t want to implement this trait on the float type. But I&rsquo;m just showing you this to emphasize how widely traits can be applied.</p>
<h3 id="associated-types">Associated Types</h3>
<p>The next feature we&rsquo;re going to introduce is called the associated type, which we&rsquo;ll use to generalize our <code>AudioProcessor</code> into a <code>Processor</code>. Associated types are types that are part of the trait definition, but are left undefined until the trait is implemented. Here&rsquo;s an example.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">trait</span> Processor {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Input</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Output</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">process</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self, input: <span style="color:#a6e22e">Self</span>::Input) -&gt; <span style="color:#a6e22e">Self</span>::Output;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>As you can see, our processor has been defined with two associated types, <code>Input</code> and <code>Output</code>. As you can see, this version captures much better the <em>essense</em> of what a processor is: a device that transforms some input into some output. We can implement it on our <code>Distortion</code> type as seen below.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">impl</span> Processor <span style="color:#66d9ef">for</span> Distortion {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Input</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">f32</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Output</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">f32</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">process</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self, input: <span style="color:#a6e22e">Self</span>::Input) -&gt; <span style="color:#a6e22e">Self</span>::Output {
</span></span><span style="display:flex;"><span>        input <span style="color:#f92672">*</span> db_to_linear(self.gain)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>We can implement this trait on our distortion multiple times if the assocated types are different. For example, we might also implement it for the 64 bit float.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">impl</span> Processor <span style="color:#66d9ef">for</span> Distortion {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Input</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">f64</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Output</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">f64</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">prepare</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self, rate: <span style="color:#66d9ef">f32</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// ignore this
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">process</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self, input: <span style="color:#a6e22e">Self</span>::Input) -&gt; <span style="color:#a6e22e">Self</span>::Output {
</span></span><span style="display:flex;"><span>        input <span style="color:#f92672">*</span> db_to_linear(self.gain)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="trait-bounds">Trait Bounds</h3>
<p>But wait! It&rsquo;s starting to look like we have some unecessary code duplication! Let&rsquo;s eliminate it using what we&rsquo;ve previously learned about generics. Now for this example, I&rsquo;m going to introduce two things.</p>
<ul>
<li>First, I&rsquo;m going to be using the <code>Float</code> crate (or library), which has a trait called <code>Float</code> that&rsquo;s implemented on various floating point numbers, including <code>f32</code> and <code>f64</code>;</li>
<li>Second, I&rsquo;m going to be using a feature known as a trait bounds, to constrain our generic parameter to implement this trait.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">use</span> float::Float;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Distortion</span><span style="color:#f92672">&lt;</span>F: <span style="color:#a6e22e">Float</span><span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    gain: <span style="color:#a6e22e">F</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>F: <span style="color:#a6e22e">Float</span><span style="color:#f92672">&gt;</span> Distortion<span style="color:#f92672">&lt;</span>F<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">new</span>() -&gt; <span style="color:#a6e22e">Self</span> {
</span></span><span style="display:flex;"><span>        Self {
</span></span><span style="display:flex;"><span>            gain: <span style="color:#a6e22e">F</span>::<span style="color:#66d9ef">ZERO</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">set_gain</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self: <span style="color:#a6e22e">gain</span>: <span style="color:#a6e22e">F</span>) {
</span></span><span style="display:flex;"><span>        self.gain <span style="color:#f92672">=</span> gain;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>F: <span style="color:#a6e22e">Float</span><span style="color:#f92672">&gt;</span> Processor <span style="color:#66d9ef">for</span> Distortion<span style="color:#f92672">&lt;</span>F<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Input</span> <span style="color:#f92672">=</span> F;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Output</span> <span style="color:#f92672">=</span> F;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">process</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self, input: <span style="color:#a6e22e">Self</span>::Input) -&gt; <span style="color:#a6e22e">Self</span>::Output {
</span></span><span style="display:flex;"><span>        input <span style="color:#f92672">*</span> db_to_linear(self.gain)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">db_to_linear</span><span style="color:#f92672">&lt;</span>F: <span style="color:#a6e22e">Float</span><span style="color:#f92672">&gt;</span>(f: <span style="color:#a6e22e">F</span>) -&gt; <span style="color:#a6e22e">F</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// something here
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> distortion <span style="color:#f92672">=</span> Distortion::new();
</span></span><span style="display:flex;"><span>    distortion.set_gain(<span style="color:#ae81ff">10.0</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> output: <span style="color:#66d9ef">f32</span> <span style="color:#f92672">=</span> distortion.process(<span style="color:#ae81ff">10.0</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>As you can see, in each of our implementations we&rsquo;ve defined a generic parameter <code>F</code>, which is constrained to be a type that implements the <code>Float</code> trait. We&rsquo;ve assigned <code>F</code> to be the input and output of our processor, and since <code>Float</code> types are guaranteed to support adding and multiplication, we can perform the necessary arithmetic in our process method.</p>
<p>Importantly, if in our <code>Processor</code> implementation, the <code>F</code> wasn&rsquo;t constrained to be a <code>Float</code>, the compiler wouldn&rsquo;t let us multiply the input with the gain value since the generic parameter wouldn&rsquo;t be guaranteed to be a type that can be multiplied.</p>
<h3 id="buffer-improvements">Buffer Improvements</h3>
<p>Let&rsquo;s implement a few useful methods to our buffer type that take advantage of some useful trait bounds.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Buffer</span><span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    items: Vec<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>F: <span style="color:#a6e22e">Float</span><span style="color:#f92672">&gt;</span> Buffer<span style="color:#f92672">&lt;</span>F<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>We can also implement some methods for our buffer type using built-in traits.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>T: Copy<span style="color:#f92672">&gt;</span> Buffer<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">init</span>(value: <span style="color:#a6e22e">T</span>, size: <span style="color:#66d9ef">usize</span>) -&gt; <span style="color:#a6e22e">Self</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> items <span style="color:#f92672">=</span> Vec::with_capacity(size);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> _ <span style="color:#66d9ef">in</span> <span style="color:#ae81ff">0</span><span style="color:#f92672">..</span>size {
</span></span><span style="display:flex;"><span>            items.push(value);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        Self { items }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>T: Copy <span style="color:#f92672">+</span> Default<span style="color:#f92672">&gt;</span> Buffer<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">new</span>(size: <span style="color:#66d9ef">usize</span>) -&gt; <span style="color:#a6e22e">Self</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> items <span style="color:#f92672">=</span> Vec::with_capacity(size);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> _ <span style="color:#66d9ef">in</span> <span style="color:#ae81ff">0</span><span style="color:#f92672">..</span>size {
</span></span><span style="display:flex;"><span>            items.push(T::default());
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        Self { items }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> buffer_1 <span style="color:#f92672">=</span> Buffer::init(<span style="color:#ae81ff">0.0</span>, <span style="color:#ae81ff">512</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> buffer_2 <span style="color:#f92672">=</span> Buffer::new(<span style="color:#ae81ff">512</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The first example&hellip;
The second example&hellip;</p>
<hr>
<h2 id="floats-samples-and-buffers">Floats, Samples, and Buffers</h2>
<p>At this point we&rsquo;ve been introduced to the basic language features we&rsquo;re going to need to develop our library. So we&rsquo;re going to take a moment to step back and think about some of the what we want this library to accomplish.</p>
<p>As mentioned earlier, we want users of our library to be able to write DSP code that&rsquo;s expressive, flexible, and composable, while being safe and performant. Here&rsquo;s some specific features we&rsquo;ll look at that together will help accomplish this goal.</p>
<ul>
<li><strong>Generic over multiple sample types</strong>: We&rsquo;ve already seen how to do this with floats specifically. We&rsquo;re also going to make our library generic over multiple <em>sample</em> types, which may have multiple channels.</li>
<li><strong>Generic over multiple buffer types</strong>: We don&rsquo;t want to restrict the user to using a single buffer type. Real audio code may need to interact with other libraries and languages, so all the buffer processing functions in our library should support our own <code>Buffer</code> type, the built-in rust buffers like <code>&amp;mut [f32]</code> and raw pointers like <code>*mut f32</code> that you might get from a C/C++ library.</li>
<li><strong>Auto implementation of useful methods</strong>: We want useful methods to be auto implemented for our types</li>
<li><strong>Simple element initialization and composition</strong>: We want to be able to easily initialize and compose our elements in to processing graphs. The syntax of the faust language is a good reference for this.</li>
</ul>
<p>Note that our goals of expressivity, flexibility, and composability are for <em>users</em> of our library. Implementing the library itself is going to require some fairly abstract uses of the Rust type system. So prepare to look at some gnarly code, knowing at the end that using our library will be much more friendly and flexible.</p>
<h3 id="sample-trait">Sample Trait</h3>
<p>We&rsquo;ve already seen how to write code that is generic over multiple float types, and our next task will be to make our library generic over multiple sample types as well. By sample here I mean a single snapshot of some continuous-time signal that may have multiple channels. So the sample might be in mono, stereo, or even spatial formats. By making our code generic over these sample types we&rsquo;ll be able to re-use the same DSP elements in all these scenarios.</p>
<p>The first step to making our library generic over sample types is to create a few of these types. Our basic, single channel types will just be float values, but we can create another one to represent a stereo sample.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Stereo</span><span style="color:#f92672">&lt;</span>F: <span style="color:#a6e22e">Float</span><span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    left: <span style="color:#a6e22e">F</span>,
</span></span><span style="display:flex;"><span>    right: <span style="color:#a6e22e">F</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>F: <span style="color:#a6e22e">Float</span><span style="color:#f92672">&gt;</span> Stereo<span style="color:#f92672">&lt;</span>F<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">pan</span>(self, db: <span style="color:#a6e22e">F</span>) -&gt; <span style="color:#a6e22e">Self</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Implement pan here
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The next step to making our library generic over sample types is to create a sample trait.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">trait</span> Sample: Copy <span style="color:#f92672">+</span> Clone <span style="color:#f92672">+</span> Add<span style="color:#f92672">&lt;</span>Self, Output <span style="color:#f92672">=</span> Self<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Float</span>: <span style="color:#a6e22e">Float</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">CHANNELS</span>: <span style="color:#66d9ef">usize</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">EQUILIBRIUM</span>: <span style="color:#a6e22e">Self</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">mono</span>(self) -&gt; <span style="color:#a6e22e">Self</span>::Float;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">sin</span>(self) -&gt; <span style="color:#a6e22e">Self</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">cos</span>(self) -&gt; <span style="color:#a6e22e">Self</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">tan</span>(self) -&gt; <span style="color:#a6e22e">Self</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">powf</span>(self, e: <span style="color:#a6e22e">Self</span>) -&gt; <span style="color:#a6e22e">Self</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">min</span>(self, rhs: <span style="color:#a6e22e">Self</span>) -&gt; <span style="color:#a6e22e">Self</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">max</span>(self, rhs: <span style="color:#a6e22e">Self</span>) -&gt; <span style="color:#a6e22e">Self</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">gain</span>(<span style="color:#f92672">&amp;</span>self, db: <span style="color:#a6e22e">Self</span>::Float) -&gt; <span style="color:#a6e22e">Self</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>As you can see here, we have declared a simple sample trait, which has an associated <code>Float</code> type, which must implement trait <code>Float</code>. It also has two associated constant values, <code>CHANNELS</code> and <code>EQUILIBRIUM</code>, which define the number of channels associated with that sample, and the &ldquo;zero&rdquo; value of it. It also has a bunch of functions that may be used on that sample type.</p>
<p>You may also have noticed at the top, that the sample trait is further constrained so it must implement the <code>Copy</code>, <code>Clone</code>, and <code>Add</code> traits (where <code>Add</code> takes a <code>Self</code> value and outputs another <code>Self</code>). If you implement a library like this for yourself you&rsquo;ll want to add a bunch of other constraints for operations like <code>Sub</code>, <code>Mul</code>, <code>Div</code>, and so on. Here&rsquo;s how you might implement the add trait for a sample.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">// TODO: Implement add trait
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// TODO: Implement add with float trait
</span></span></span></code></pre></div><p>This will allow us to add these floats as is shown below.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">// Example adding two samples
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Example adding sample with float
</span></span></span></code></pre></div><p>The next step would be to implement this sample trait for every sample type we want to support. I&rsquo;m not going to do that now but the process would look something like this.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">impl</span> Sample <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">f32</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Float</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">f32</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">CHANNELS</span>: <span style="color:#66d9ef">usize</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">EQUILIBRIUM</span>: <span style="color:#a6e22e">Self</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">mono</span>(self) -&gt; <span style="color:#a6e22e">Self</span>::Float {
</span></span><span style="display:flex;"><span>        self
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// And so on below...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>F: <span style="color:#a6e22e">Float</span><span style="color:#f92672">&gt;</span> Sample <span style="color:#66d9ef">for</span> Stereo<span style="color:#f92672">&lt;</span>F<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Float</span> <span style="color:#f92672">=</span> F;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">CHANNELS</span>: <span style="color:#66d9ef">usize</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">EQUILIBRIUM</span>: <span style="color:#a6e22e">Self</span> <span style="color:#f92672">=</span> Sample {
</span></span><span style="display:flex;"><span>        left: <span style="color:#a6e22e">F</span>::<span style="color:#66d9ef">EQUILIBRIUM</span>,
</span></span><span style="display:flex;"><span>        right: <span style="color:#a6e22e">F</span>::<span style="color:#66d9ef">EQUILIBRIUM</span>
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">mono</span>(self) -&gt; <span style="color:#a6e22e">Self</span>::Float {
</span></span><span style="display:flex;"><span>        self.left <span style="color:#f92672">+</span> self.right
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// And so on below...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>And you could continue expanding this list to include support for spatial audio formats or any othr kind of sample you like.</p>
<h3 id="block-trait">Block Trait</h3>
<p>Now that we&rsquo;ve got the basic building blocks for making our library generic over different sample types, we&rsquo;re going to use this while implementing the trait that will make our library generic over different <em>buffer</em> types. To do this we&rsquo;re going to implement a <code>Block</code> trait, which will represent a non-owned frame of samples or some other data. Here&rsquo;s a first implementation.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">trait</span> Block {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Item</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">as_slice</span>(<span style="color:#f92672">&amp;</span>self) -&gt; <span style="color:#66d9ef">&amp;</span>[Self::Item];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">as_slice_mut</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self) -&gt; <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">mut</span> [Self::Item];
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Most generically, a block is a list of <em>items</em>, so we have the corresponding <code>Item</code> associated type. For our block to be useful we must be able to access these items somehow, so we&rsquo;re going to retrieve them as a slice (or list) of these items.</p>
<p>We can implement other useful default methods on our block using type constraints. For example, we&rsquo;ll first implement an <code>rms</code> method when the block contains samples. First consider the signature of this method. What we want to do is constrain our function so that it is only available when the block <code>Item</code> implements <code>Sample</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">rms</span>(<span style="color:#f92672">&amp;</span>self) -&gt; <span style="color:#a6e22e">Self</span>::Item <span style="color:#66d9ef">where</span> Self::Item: <span style="color:#a6e22e">Sample</span>;
</span></span></code></pre></div><p>Here&rsquo;s the appropriate constraint. Now we just need to provide a default implementation in our block trait.</p>
<p>First</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">trait</span> Block {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Item</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">as_slice</span>(<span style="color:#f92672">&amp;</span>self) -&gt; <span style="color:#66d9ef">&amp;</span>[Self::Item];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">as_slice_mut</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self) -&gt; <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">mut</span> [Self::Item];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">rms</span>(<span style="color:#f92672">&amp;</span>self) -&gt; <span style="color:#a6e22e">Self</span>::Item <span style="color:#66d9ef">where</span> Self::Item: <span style="color:#a6e22e">Sample</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> count <span style="color:#f92672">=</span> Self::Item::from(self.len());
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> acc <span style="color:#f92672">=</span> Self::Item::<span style="color:#66d9ef">EQUILIBRIUM</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> s <span style="color:#66d9ef">in</span> self.as_slice() {
</span></span><span style="display:flex;"><span>            acc <span style="color:#f92672">+=</span> <span style="color:#f92672">*</span>s <span style="color:#f92672">/</span> count;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> acc;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>As you can see, this method is a bit more complicated than ones you might have seen implemented on concrete types. The advantage of this approach is that this method will now be available in our library for any combination of types that implement <code>Float</code> and <code>Block</code>.</p>
<p>As an example that will mutate the block, we&rsquo;ll also add a <code>copy_from</code> method that will copy the values from some source block to our current one.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">copy_from</span><span style="color:#f92672">&lt;</span>B<span style="color:#f92672">&gt;</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self, src: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">B</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">where</span>
</span></span><span style="display:flex;"><span>            Self::Item: Copy 
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">B</span>: <span style="color:#a6e22e">Block</span><span style="color:#f92672">&lt;</span>Item <span style="color:#f92672">=</span> Self::Item<span style="color:#f92672">&gt;&gt;</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        self.as_slice_mut()
</span></span><span style="display:flex;"><span>            .copy_from_slice(src.as_slice());
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><p>The signature of the <code>copy_from</code> method might look a bit complicated, but if you walk through it you can see that it&rsquo;s actually fairly simple. The method first declares a generic parameter <code>B</code>, and as arguments takes a mutable reference to self and an immutable reference to some source block. The first constraint ensures that <code>Item</code> is copyable, so we can copy it from one block to the other. The second constraint ensures that the items in the source and destination block are the same type.</p>
<p>Our last step before being able to use these methods is to implement our <code>Block</code> trait on all the types we want to support it. Firs we&rsquo;ll implement it on the buffer type we started working on earlier.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> Block <span style="color:#66d9ef">for</span> Buffer<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Item</span> <span style="color:#f92672">=</span> T;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">as_slice</span>(<span style="color:#f92672">&amp;</span>self) -&gt; <span style="color:#66d9ef">&amp;</span>[T] {
</span></span><span style="display:flex;"><span>        self.items.as_slice()
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">as_slice_mut</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self) -&gt; <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">mut</span> [T] {
</span></span><span style="display:flex;"><span>        self.items.as_mut_slice()
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Here&rsquo;s implementing our trait for <code>[S]</code> the built-in rust array type.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>S<span style="color:#f92672">&gt;</span> Block <span style="color:#66d9ef">for</span> [S] {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Item</span> <span style="color:#f92672">=</span> S;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">as_slice</span>(<span style="color:#f92672">&amp;</span>self) -&gt; <span style="color:#66d9ef">&amp;</span>[Self::Item] {
</span></span><span style="display:flex;"><span>        self
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">as_slice_mut</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self) -&gt; <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">mut</span> [Self::Item] {
</span></span><span style="display:flex;"><span>        self
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>And here&rsquo;s implementing our trait for <code>(*mut S, usize)</code>, a tuple containing a raw pointer to a sample and a size.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>S<span style="color:#f92672">&gt;</span> Block <span style="color:#66d9ef">for</span> (<span style="color:#f92672">*</span><span style="color:#66d9ef">mut</span> S, <span style="color:#66d9ef">usize</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Item</span> <span style="color:#f92672">=</span> S;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">as_slice</span>(<span style="color:#f92672">&amp;</span>self) -&gt; <span style="color:#66d9ef">&amp;</span>[Self::Item] {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">unsafe</span> {
</span></span><span style="display:flex;"><span>            std::slice::from_raw_parts(self.<span style="color:#ae81ff">0</span>, self.<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">as_slice_mut</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self) -&gt; <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">mut</span> [Self::Item] {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">unsafe</span> {
</span></span><span style="display:flex;"><span>            std::slice::from_raw_parts_mut(self.<span style="color:#ae81ff">0</span>, self.<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Now that we&rsquo;ve got a couple methods implemented on our traits, we can get a sense of the payoff to these more abstract implementations when using the library. Take a look at the following example.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">test_mono</span>(
</span></span><span style="display:flex;"><span>        buffer_1: (<span style="color:#f92672">*</span><span style="color:#66d9ef">mut</span> <span style="color:#66d9ef">f32</span>, <span style="color:#66d9ef">usize</span>),
</span></span><span style="display:flex;"><span>        buffer_2: <span style="color:#66d9ef">&amp;</span>[<span style="color:#66d9ef">f32</span>]
</span></span><span style="display:flex;"><span>        buffer_3: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">Buffer</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">f32</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>    ) -&gt; <span style="color:#a6e22e">Buffer</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">f32</span><span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> sum <span style="color:#f92672">=</span> Buffer::init(<span style="color:#ae81ff">0.0</span>, count);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    sum.copy_from(<span style="color:#f92672">&amp;</span>buffer_1);
</span></span><span style="display:flex;"><span>    sum.copy_from(<span style="color:#f92672">&amp;</span>buffer_2);
</span></span><span style="display:flex;"><span>    sum.copy_from(<span style="color:#f92672">&amp;</span>buffer_3);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    buffer_3.copy_from(<span style="color:#f92672">&amp;</span>buffer_1);
</span></span><span style="display:flex;"><span>    buffer_2.copy_from(<span style="color:#f92672">&amp;</span>buffer_3);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> rms <span style="color:#f92672">=</span> buffer_2.rms();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>As you can see, the first method copies data from a raw pointer of floats to our custom buffer, and also from this buffer to the built-in slice type. All of these calls use the same <code>copy_from</code> implementation. The first method uses the <code>f32</code> as the float type, but you could use any sample type, or even make the function generic over every sample type. Here&rsquo;s an example of that.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">test_generic</span><span style="color:#f92672">&lt;</span>S: <span style="color:#a6e22e">Sample</span><span style="color:#f92672">&gt;</span>(
</span></span><span style="display:flex;"><span>        buffer_1: (<span style="color:#f92672">*</span><span style="color:#66d9ef">mut</span> S, <span style="color:#66d9ef">usize</span>),
</span></span><span style="display:flex;"><span>        buffer_2; <span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> [S]
</span></span><span style="display:flex;"><span>    ) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> buffer_3 <span style="color:#f92672">=</span> Buffer::init(S::<span style="color:#66d9ef">EQUILIBRIUM</span>, count);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    buffer_3.copy_from(<span style="color:#f92672">&amp;</span>buffer_1);
</span></span><span style="display:flex;"><span>    buffer_2.copy_from(<span style="color:#f92672">&amp;</span>buffer_3);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> rms <span style="color:#f92672">=</span> buffer_2.rms().mono();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="more-methods">More Methods</h3>
<p>The final thing you&rsquo;ll want to do is implement a laundry list of useful functions on our block and float traits. These could include methods for adding blocks, equilibrating a block, applying a function across a block, and more. These implementation will automatically become supported on all the different block types, and will be also supported <em>between</em> all the different combinations of block types. Here&rsquo;s a few examples.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span>    <span style="color:#e6db74">/// Apply a function to each sample
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">apply</span><span style="color:#f92672">&lt;</span>F: Fn(Self::Item) -&gt; <span style="color:#a6e22e">Self</span>::Item<span style="color:#f92672">&gt;</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self, f: <span style="color:#a6e22e">F</span>) <span style="color:#66d9ef">where</span> Self::Item: Copy {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> v <span style="color:#66d9ef">in</span> self.as_slice_mut() {
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">*</span>v <span style="color:#f92672">=</span> f(<span style="color:#f92672">*</span>v);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">/// Apply a gain to the buffer
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">gain</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self, db: <span style="color:#f92672">&lt;</span>Self::Item <span style="color:#66d9ef">as</span> Sample<span style="color:#f92672">&gt;</span>::Float) <span style="color:#66d9ef">where</span> Self::Item: <span style="color:#a6e22e">Sample</span> {
</span></span><span style="display:flex;"><span>        self.apply(<span style="color:#f92672">|</span> v <span style="color:#f92672">|</span> v.gain(db))
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">/// Fill the buffer with a value
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">fill</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self, value: <span style="color:#a6e22e">Self</span>::Item) <span style="color:#66d9ef">where</span> Self::Item: Copy {
</span></span><span style="display:flex;"><span>        self.apply(<span style="color:#f92672">|</span> _ <span style="color:#f92672">|</span> { value } );
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">/// Equilibrate the buffer
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">equilibrate</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self) <span style="color:#66d9ef">where</span> Self::Item: <span style="color:#a6e22e">Sample</span> {
</span></span><span style="display:flex;"><span>        self.fill(Self::Item::<span style="color:#66d9ef">EQUILIBRIUM</span>);
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><p>And these methods can be used as shown below.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#e6db74">/// Test on a buffer of stereo 32 bit floats
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">test_1</span>(buffer: <span style="color:#a6e22e">Buffer</span><span style="color:#f92672">&lt;</span>Stereo<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">f32</span><span style="color:#f92672">&gt;&gt;</span>) {
</span></span><span style="display:flex;"><span>    buffer.fill(Stereo::from(<span style="color:#ae81ff">0.0</span>));
</span></span><span style="display:flex;"><span>    buffer.gain(<span style="color:#ae81ff">10.0</span>);
</span></span><span style="display:flex;"><span>    buffer.fill(Stereo::from(<span style="color:#ae81ff">0.5</span>));
</span></span><span style="display:flex;"><span>    buffer.apply(<span style="color:#f92672">|</span> s <span style="color:#f92672">|</span> s <span style="color:#f92672">+</span> <span style="color:#ae81ff">1.0</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#e6db74">/// Test on a raw pointer to 32 bit floats
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">test_2</span>(buffer: (<span style="color:#f92672">*</span><span style="color:#66d9ef">mut</span> <span style="color:#66d9ef">f32</span>, <span style="color:#66d9ef">usize</span>)) {
</span></span><span style="display:flex;"><span>    buffer.fill(<span style="color:#ae81ff">0.0</span>);
</span></span><span style="display:flex;"><span>    buffer.gain(<span style="color:#ae81ff">10.0</span>);
</span></span><span style="display:flex;"><span>    buffer.fill(<span style="color:#ae81ff">0.5</span>);
</span></span><span style="display:flex;"><span>    buffer.apply(<span style="color:#f92672">|</span> s <span style="color:#f92672">|</span> s <span style="color:#f92672">+</span> <span style="color:#ae81ff">1.0</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Okay. I think that covers how to implement abstract methods over all the combinations of float, sample, and buffer types. Regardless of if you thought any of the abstract code was complicated, I hope these final examples made it clear how simple and flexible the end result is. Remember, these functions can now be used with any permutation of float type, channel formats, and buffer type.</p>
<hr>
<h2 id="processors-and-generators">Processors and Generators</h2>
<p>Next we&rsquo;re going to take a closer look at DSP processors, and how they can be represented in a way that&rsquo;s abstract and composable. Just a reminder from earlier, we represented processors with the following trait, which consumes an input and yields an output.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">trait</span> Processor {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Input</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Output</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">prepare</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self, sample_rate: <span style="color:#66d9ef">f64</span>, block_size: <span style="color:#66d9ef">usize</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">process</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self, input: <span style="color:#a6e22e">Self</span>::Input) -&gt; <span style="color:#a6e22e">Self</span>::Output;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>And while we&rsquo;re add it we&rsquo;ll also create a generator trait, which only produces an output.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">trait</span> Generator {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Output</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">prepare</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self, sample_rate: <span style="color:#66d9ef">f64</span>, block_size: <span style="color:#66d9ef">usize</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">generate</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self) -&gt; <span style="color:#a6e22e">Self</span>::Output;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>What we&rsquo;re going to try to do is use the trait system to allow types that implement these traits to be composed into audio graphs with operators, similar to the faust programming language. Here&rsquo;s a preview of where we&rsquo;re going.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> dsp <span style="color:#f92672">=</span> noise() <span style="color:#f92672">&gt;&gt;</span> gain(lfo(<span style="color:#ae81ff">10.0</span>) <span style="color:#f92672">&gt;&gt;</span> gain(<span style="color:#f92672">-</span><span style="color:#ae81ff">20.0</span>));
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> output: <span style="color:#66d9ef">f32</span> <span style="color:#f92672">=</span> dsp.generate();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>There&rsquo;s two main elements to this method of graph initialization. First there&rsquo;s the audio node initialization, which is done with <code>const</code> functions, and second there&rsquo;s how we&rsquo;re composing these elements into the graph with operators. We&rsquo;ll start by considering the node composition.</p>
<h3 id="node-composition">Node Composition</h3>
<p>We&rsquo;ll start by implementing chain composition, which will be accomplished by the <code>&gt;&gt;</code> right shift operator. To support this we&rsquo;ll need to implement the <code>Shr</code> trait. Two elements composed with this operator will feed into each other from left to right.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">trait</span> Shr<span style="color:#f92672">&lt;</span>Rhs <span style="color:#f92672">=</span> Self<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Output</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">shr</span>(self, rhs: <span style="color:#a6e22e">Rhs</span>) -&gt; <span style="color:#a6e22e">Self</span>::Output;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>We&rsquo;re going to implement the <code>Shr</code> trait on a single type, but we want to be able to compose a variety of different processors and generators. So for this to work we&rsquo;ll need to create a <code>Node</code> wrapper type that can be composd with our operators, and these node types should be able to play back any processor or generator that it contains.</p>
<p>Here&rsquo;s a simple declaration of our node type.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">#[derive(Copy, Clone)]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Node</span><span style="color:#f92672">&lt;</span>P<span style="color:#f92672">&gt;</span>(<span style="color:#66d9ef">pub</span> P);
</span></span></code></pre></div><p>To drive the conceptual point home, you can see the following diagram, which shows how each generator and processor is wrapped in a <code>Node</code> type, and how each of these nodes is being composed with operators.</p>
<pre tabindex="0"><code>    Node( Generator1 ) &gt;&gt; Node( Processor2 ) &gt;&gt; Node( Processor3 )
</code></pre><p>Now consider each of the operators. How can we use the <code>Shr</code> trait to get the desired chaining functionality? We&rsquo;ll use the trait to generate a <code>struct Chain</code>, which wraps the elements on either side of the operator and calls them in the appropriate order. A <code>struct Chain</code> will contain two elements that are fed into one other, as shown in the diagram below. These chains may be composed recursively.</p>
<pre tabindex="0"><code>    Chain( Node( Generator1 ), Chain( Node( Processor1 ), Node( Processor2 ) ) )
</code></pre><p>This diagram represents the data structure that we want our operators to generate. Since we already implemented the <code>Node</code> struct, we&rsquo;ll need to implement the <code>Chain</code> struct next.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">#[derive(Copy, Clone)]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Chain</span><span style="color:#f92672">&lt;</span>P1, P2<span style="color:#f92672">&gt;</span>(<span style="color:#66d9ef">pub</span> P1, <span style="color:#66d9ef">pub</span> P2);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>In, Between, Out, P1, P2<span style="color:#f92672">&gt;</span> Processor <span style="color:#66d9ef">for</span> Chain<span style="color:#f92672">&lt;</span>P1, P2<span style="color:#f92672">&gt;</span> 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">where</span>
</span></span><span style="display:flex;"><span>        P1: <span style="color:#a6e22e">Processor</span><span style="color:#f92672">&lt;</span>Input <span style="color:#f92672">=</span> In, Output <span style="color:#f92672">=</span> Between<span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>        P2: <span style="color:#a6e22e">Processor</span><span style="color:#f92672">&lt;</span>Input <span style="color:#f92672">=</span> Between, Output <span style="color:#f92672">=</span> Out<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Input</span> <span style="color:#f92672">=</span> In;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Output</span> <span style="color:#f92672">=</span> Out;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">prepare</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self, sample_rate: <span style="color:#66d9ef">f64</span>, block_size: <span style="color:#66d9ef">usize</span>) {
</span></span><span style="display:flex;"><span>        self.<span style="color:#ae81ff">0.</span>prepare(sample_rate, block_size);
</span></span><span style="display:flex;"><span>        self.<span style="color:#ae81ff">1.</span>prepare(sample_rate, block_size);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">process</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self, input: <span style="color:#a6e22e">Self</span>::Input) -&gt; <span style="color:#a6e22e">Self</span>::Output {
</span></span><span style="display:flex;"><span>        self.<span style="color:#ae81ff">1.</span>process(self.<span style="color:#ae81ff">0.</span>process(input))
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>Between, Out, G, P<span style="color:#f92672">&gt;</span> Generator <span style="color:#66d9ef">for</span> Chain<span style="color:#f92672">&lt;</span>G, P<span style="color:#f92672">&gt;</span> 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">where</span>
</span></span><span style="display:flex;"><span>        G: <span style="color:#a6e22e">Generator</span><span style="color:#f92672">&lt;</span>Output <span style="color:#f92672">=</span> Between<span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>        P: <span style="color:#a6e22e">Processor</span><span style="color:#f92672">&lt;</span>Input <span style="color:#f92672">=</span> Between, Output <span style="color:#f92672">=</span> Out<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Output</span> <span style="color:#f92672">=</span> Out;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">reset</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self) {}
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">prepare</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self, _sample_rate: <span style="color:#66d9ef">f64</span>, _block_size: <span style="color:#66d9ef">usize</span>) {}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">generate</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self) -&gt; <span style="color:#a6e22e">Self</span>::Output {
</span></span><span style="display:flex;"><span>        self.<span style="color:#ae81ff">1.</span>process(self.<span style="color:#ae81ff">0.</span>generate())
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The heavy use of generics in this example may look intimidating, but it&rsquo;s actually fairly simple. Take a look at our implementation of <code>Generator</code> for <code>Chain</code>. you can see that there are generic parameters <code>G</code> and <code>P</code> for the generator at the beginning of the chain and the processor next in the chain. then their are two generic parameters <code>Between</code> and <code>Out</code>, which represent the data types between the two elements and the output of the whole chain. These type constraints you see here are meant to ensure that the output of the first element is the same as the input to the second element. Then you can see the process method will first call member <code>0</code>, then feed the output into the call to member <code>1</code>, exactly what we&rsquo;d expect from a chain.</p>
<p>Now that we have the <code>Node</code> and <code>Chain</code> types, we can implement the code that will generate these types from our operators. We&rsquo;ll start with the <code>Shr</code> operator for creating chains.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>A, B<span style="color:#f92672">&gt;</span> std::ops::Shr<span style="color:#f92672">&lt;</span>Node<span style="color:#f92672">&lt;</span>B<span style="color:#f92672">&gt;&gt;</span> <span style="color:#66d9ef">for</span> Node<span style="color:#f92672">&lt;</span>A<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Output</span> <span style="color:#f92672">=</span> Node<span style="color:#f92672">&lt;</span>Chain<span style="color:#f92672">&lt;</span>A, B<span style="color:#f92672">&gt;&gt;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">shr</span>(self, rhs: <span style="color:#a6e22e">Node</span><span style="color:#f92672">&lt;</span>B<span style="color:#f92672">&gt;</span>) -&gt; <span style="color:#a6e22e">Self</span>::Output {
</span></span><span style="display:flex;"><span>        Node(Chain(self.<span style="color:#ae81ff">0</span>, rhs.<span style="color:#ae81ff">0</span>))
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>When the <code>&gt;&gt;</code> is applied, it will tranform the nodes on either side into a single node, containing a chain of the previous nodes. Now we&rsquo;ve implemented the code we need to compose audio nodes. Our next step is to create the functions that will produce these nodes from our processors and generators.</p>
<h3 id="node-initialization">Node Initialization</h3>
<p>We&rsquo;re going to start with a implementation of a <code>struct Gain</code>, which implements <code>Processor</code> generically over all samples.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Gain</span><span style="color:#f92672">&lt;</span>S: <span style="color:#a6e22e">Sample</span><span style="color:#f92672">&gt;</span>(S::Float);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>S: <span style="color:#a6e22e">Sample</span><span style="color:#f92672">&gt;</span> Gain<span style="color:#f92672">&lt;</span>S<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">from</span>(db: <span style="color:#a6e22e">S</span>::Float) -&gt; <span style="color:#a6e22e">Gain</span><span style="color:#f92672">&lt;</span>S<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>        Gain(db)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>S: <span style="color:#a6e22e">Sample</span><span style="color:#f92672">&gt;</span> Processor <span style="color:#66d9ef">for</span> Gain<span style="color:#f92672">&lt;</span>S<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Input</span> <span style="color:#f92672">=</span> S;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Output</span> <span style="color:#f92672">=</span> S;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">prepare</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self, _sample_rate: <span style="color:#66d9ef">f64</span>, _block_size: <span style="color:#66d9ef">usize</span>) {}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">process</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self, input: <span style="color:#a6e22e">Self</span>::Input) -&gt; <span style="color:#a6e22e">Self</span>::Output {
</span></span><span style="display:flex;"><span>        input.gain(self.<span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>We can create a const function that creates an audio node from this struct as shown below.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">gain</span><span style="color:#f92672">&lt;</span>S: <span style="color:#a6e22e">Sample</span><span style="color:#f92672">&gt;</span>(db: <span style="color:#a6e22e">S</span>::Float) -&gt; <span style="color:#a6e22e">Node</span><span style="color:#f92672">&lt;</span>Gain<span style="color:#f92672">&lt;</span>S<span style="color:#f92672">&gt;&gt;</span> {
</span></span><span style="display:flex;"><span>    Node(Gain(db))
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="testing">Testing</h3>
<p>Now we should have everything we need to start composing nodes. You can assume I repeated this process for some other processors and generators.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> noise <span style="color:#f92672">=</span> noise();        <span style="color:#75715e">// Creates Node(Noise)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> gain <span style="color:#f92672">=</span> gain(<span style="color:#ae81ff">10.0</span>);      <span style="color:#75715e">// Creates Node(Gain(10.0))
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> dsp <span style="color:#f92672">=</span> noise <span style="color:#f92672">&gt;&gt;</span> gain_1;  <span style="color:#75715e">// Creates Node(Chain(Node(Noise), Node(Gain(10.0))))
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>The last thing we want is to be able to call the generator and processor methods on our nodes. To do this we need to implement these traits on <code>Node</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>Out, G<span style="color:#f92672">&gt;</span> Generator <span style="color:#66d9ef">for</span> Node<span style="color:#f92672">&lt;</span>G<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">where</span>
</span></span><span style="display:flex;"><span>        G: <span style="color:#a6e22e">Generator</span><span style="color:#f92672">&lt;</span>Output <span style="color:#f92672">=</span> Out<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Output</span> <span style="color:#f92672">=</span> Out;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">prepare</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self, sample_rate: <span style="color:#66d9ef">f64</span>, block_size: <span style="color:#66d9ef">usize</span>) {
</span></span><span style="display:flex;"><span>        self.<span style="color:#ae81ff">0.</span>prepare(sample_rate, block_size);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">generate</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self) -&gt; <span style="color:#a6e22e">Self</span>::Output {
</span></span><span style="display:flex;"><span>        self.<span style="color:#ae81ff">0.</span>generate()
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>In, Out, P<span style="color:#f92672">&gt;</span> Processor <span style="color:#66d9ef">for</span> Node<span style="color:#f92672">&lt;</span>P<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">where</span>
</span></span><span style="display:flex;"><span>        P: <span style="color:#a6e22e">Processor</span><span style="color:#f92672">&lt;</span>Input <span style="color:#f92672">=</span> In, Output <span style="color:#f92672">=</span> Out<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Input</span> <span style="color:#f92672">=</span> In;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Output</span> <span style="color:#f92672">=</span> Out;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">prepare</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self, sample_rate: <span style="color:#66d9ef">f64</span>, block_size: <span style="color:#66d9ef">usize</span>) {
</span></span><span style="display:flex;"><span>        self.<span style="color:#ae81ff">0.</span>prepare(sample_rate, block_size);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">process</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self, input: <span style="color:#a6e22e">Self</span>::Input) -&gt; <span style="color:#a6e22e">Self</span>::Output {
</span></span><span style="display:flex;"><span>        self.<span style="color:#ae81ff">0.</span>process(input)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>As you can see, each trait is only implemented if the element contained by the node also implements the trait. So, for example, the processor trait will only be implemented for the node if the containing member is also a processors.</p>
<p>Now we can freely compose our nodes as is shown below.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> block <span style="color:#f92672">=</span> Block::init(<span style="color:#ae81ff">0.0</span>, <span style="color:#ae81ff">512</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> graph <span style="color:#f92672">=</span> noise() <span style="color:#f92672">&gt;&gt;</span> gain(<span style="color:#ae81ff">10.0</span>) <span style="color:#f92672">&gt;&gt;</span> gain(<span style="color:#f92672">-</span><span style="color:#ae81ff">10.0</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    graph.generate_block(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> block);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Since this graph starts with a generator, and ends with processors, the generator methods are avaliable on the whole chain. If I switch the first element to a processor, however, then you&rsquo;ll see the generator methods are no longer available and I can intead call the processor methods. This is the magic of type inteference.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> input <span style="color:#f92672">=</span> Block::init(<span style="color:#ae81ff">0.0</span>, <span style="color:#ae81ff">512</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> output <span style="color:#f92672">=</span> Block::init(<span style="color:#ae81ff">0.0</span>, <span style="color:#ae81ff">512</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> graph <span style="color:#f92672">=</span> distotion(<span style="color:#ae81ff">10.0</span>) <span style="color:#f92672">&gt;&gt;</span> gain(<span style="color:#ae81ff">10.0</span>) <span style="color:#f92672">&gt;&gt;</span> gain(<span style="color:#f92672">-</span><span style="color:#ae81ff">10.0</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    graph.process_block(<span style="color:#f92672">&amp;</span>input, <span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> output);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This general strategy can be expaneded to include splitting and combining streams of data, using the <code>|</code> and the <code>&amp;</code> operatos, for example. Remember, these nodes we&rsquo;ve created are generic over all the float, sample, and buffer types we created previously.</p>
<h2 id="summary">Summary</h2>

            </div>
        </article>

        <hr />

        <div class="post-info">
            
    <p>
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon"><path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7" y2="7"></line></svg>

        <span class="tag"><a href="http://localhost:1313/tags/rust/">Rust</a></span>
        <span class="tag"><a href="http://localhost:1313/tags/audio-programming/">Audio Programming</a></span>
        
    </p>

            
  		</div>
    </main>

            </div>

            
                <footer class="footer">
    
    <div class="footer__inner">
        <div class="footer__content">
            <span>&copy; 2023</span>
            <span><a href="http://localhost:1313/">Chase Kanipe</a></span>
            <span></span>
            
            
        </div>
    </div>
    
    
</footer>

            
        </div>

        



<script type="text/javascript" src="/bundle.min.008ec5e3e41352c0aeb118ff7eb448d3a1f41ece151fd54de1e6dbdd8760307771f5ccc1fb5d8020598777d4f62242c51348194870ea9634f15cd763bf3d538b.js" integrity="sha512-AI7F4&#43;QTUsCusRj/frRI06H0Hs4VH9VN4ebb3YdgMHdx9czB&#43;12AIFmHd9T2IkLFE0gZSHDqljTxXNdjvz1Tiw=="></script>



    </body>
</html>
